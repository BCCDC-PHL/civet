```python, name="header",echo=False, results='raw'
import os
figdir = "" ##CHANGE
sequencing_centre = "" ##CHANGE

if sequencing_centre != "":
    header_file = os.path.join(figdir, sequencing_centre)
    print(f"![]({header_file})")

    sequencing_centre = sequencing_centre.split(".")[0]

    print("# Cluster investigation for sequences generated by " + sequencing_centre)

else:
    header_file = os.path.join(figdir, "DEFAULT.png")
    print(f"![]({header_file})")

    print("# Cluster investigation")
```

```python, name="import dependencies", echo=False
import matplotlib.pyplot as pyplot
import pandas as pd 
import os
import data_parsing as dp
import make_tree_figures as tree_viz
import matplotlib.font_manager as font_manager
import matplotlib as mpl
from collections import defaultdict
import tabulate
import datetime as dt
import csv
import numpy as np
import scipy as sp

from dateutil.relativedelta import relativedelta, FR

thisdir = os.path.abspath(os.path.dirname(__file__))
cwd = os.getcwd()


filtered_cog_metadata = "" ##CHANGE
input_csv = "" ##CHANGE
full_metadata_file = "" ##CHANGE
desired_fields = "" ##CHANGE

tree_dir = "" ##CHANGE

QC_fail_file = "" ##CHANGE
missing_seq_file = "" ##CHANGE

input_directory = "" ##CHANGE

output_directory = "" ##CHANGE
name_stem_input = "" ##CHANGE

local_lineage = "" ##CHANGE
date_restriction = "" ##CHANGE
date_start= "" ##CHANGE
date_end = "" ##CHANGE
date_window_size = "" ##CHANGE


if "/" in name_stem_input:
    name_stem = name_stem_input.split("/")[-1]
else:
    name_stem = name_stem_input

desired_fields_input = "" ##CHANGE
summary_dir = "" ##CHANGE

desired_fields = []
if desired_fields_input != "":
    options = desired_fields_input.split(",")
    for i in options: 
        desired_fields.append(i)


#font_list = font_manager.fontManager.addfont(font_file)
font_props = font_manager.FontProperties(family=["sans-serif"])
#font_props = font_manager.FontProperties(family=["helveticaneue","helvetica","definitelynotarial",'sans-serif'])

a = matplotlib.font_manager.FontManager()
a.findfont(font_props, fallback_to_default=True)

pyplot.rcParams.update({'figure.max_open_warning': 0})

#mpl.rcParams['font.family'] = 'helveticaneue'
mpl.rcParams['font.weight']=50
mpl.rcParams['axes.labelweight']=50

```



```python, name="parse metadata", echo=False, results='raw'

present_in_tree, tip_to_tree = dp.parse_tree_tips(tree_dir)

query_dict, query_id_dict, present_lins, tree_to_tip = dp.parse_reduced_metadata(filtered_cog_metadata, tip_to_tree) #Just the lines with their queries plus the closest match in COG
if input_csv != '':
    adm2_to_adm1 = dp.prepping_adm2_adm1_data(full_metadata_file)
    query_dict = dp.parse_input_csv(input_csv, query_id_dict, desired_fields, adm2_to_adm1, False) #Any query information they have provided

full_tax_dict = dp.parse_full_metadata(query_dict, full_metadata_file, present_lins, present_in_tree)
```

```python, name="QC fails", echo=False, results="raw"
count_fails = 0
count_missing = 0

with open(missing_seq_file) as f:
    for l in f:
        if "name" not in l:
            count_missing += 1

if QC_fail_file != "": 
    with open(QC_fail_file) as f:
        next(f)
        for l in f:
            count_fails += 1

if count_fails != 0 or count_missing != 0:
    if count_fails != 0:
        fail_dict = dp.investigate_QC_fails(QC_fail_file)
        if len(fail_dict) > 0:
            print("The following sequences have failed QC:\n")
            for seq, reason in fail_dict.items():
                pretty_name = seq.replace("'","")
                pretty_reason = reason.replace("'","")
                print(" - " + pretty_name, pretty_reason)
    if count_missing != 0:
        print("\n")
        failed_names = dp.print_missing_seqs(missing_seq_file)
        print("The following seqs were not found in COG and a fasta file was not provided, so CIVET was unable to add them into phylogenies:\n")
        for i in failed_names:
            print(" - " + i.replace("'","")) 
```

```python, name="early descriptions", echo=False, results='tex'
number_seqs = len(query_dict)

cog_number = 0
not_in_cog_number = 0
for tax in query_dict.values():
    if tax.in_cog:
        cog_number += 1
    else:
        not_in_cog_number += 1

print("You provided " + str(number_seqs) + " sequences in total.")

if cog_number != 0 and not_in_cog_number != 0:
    print(str(cog_number) + " were found in the COG database, leaving " + str(not_in_cog_number) + " which were not.")
elif cog_number == 0:
    print("None of the sequences were found in the COG database.")
elif not_in_cog_number == 0:
    print("All of the sequences were found in the COG database.")

```

The table below is a summary of these sequences provided with your metadata, along with their associated UK lineage and global lineage. 

If you have provided additional information in the input csv, and specified that you would like it included in the analysis, it will also be displayed here.

```python, name="first_table", echo=False, results="tex"

df = dp.make_initial_table(query_dict, desired_fields, False)

print(df.to_markdown())
```

## Phylogenies

The nearest neighbours of each of the query sequences are shown below in order to show their phylogenetic context.

They are coloured by the input field you have specified. 
If no fields were specified, they are coloured by Adm1. 

If there was no geographical information provided (either adm1 or adm2), the sequences are left uncoloured. 
If you would like them to be coloured by specific metadata, please provide this names of the appropriate metadata columns on the command line.


```python, name="make_trees", echo=False, include=False, figure=False
too_tall_trees, overall_tree_number, colour_dict_dict, overall_df_dict = tree_viz.make_all_of_the_trees(tree_dir, full_tax_dict, query_id_dict, query_dict, desired_fields)
```
```python, name="make_legend", echo=False, include=False
for colour_dict in colour_dict_dict.values():
    tree_viz.make_legend(colour_dict)
```
```python,name="show_legend",echo=False,results='raw'
for i, trait in enumerate(colour_dict_dict.keys()):
    print("The legend for " + trait + " is shown below.\n")
    print("![](" + figdir + "/" + name_stem + "_make_legend_" + str(i+1) + ".png)")
    print("\n")
```
```python, name="show_trees", echo=False, results='raw'
if len(desired_fields) == 1:
    for i in range(1,overall_tree_number+1):
        tree_name = "Tree " + str(i)
        lookup = "tree_" + str(i)
        if len(tree_to_tip[lookup]) == 1:
            print("Tree number " + str(i) + " contains " + str(len(tree_to_tip[lookup])) + " query.")
            print("Given that there are no other sequences in the query dataset that are in this tree, transmission between this sequence and other queries can be ruled out.")
        else:
            print("Tree number " + str(i) + " contains " + str(len(tree_to_tip[lookup])) + " queries.")
            print("There are multiple query sequences in this tree, and so transmission cannot be ruled out, but neither can it be confirmed. Therefore their relationship must be investigated further using epidemiological data.")
        print("   ")
        print("![](" + figdir + "/" + name_stem + "_make_trees_" + str(i) + ".png)")

else:
    for i in range(1,overall_tree_number+1):
        tree_name = "Tree " + str(i)
        lookup = "tree_" + str(i)
        if len(tree_to_tip[lookup]) == 1:
            print("Tree number " + str(i) + " contains " + str(len(tree_to_tip[lookup])) + " query.")
            print("Given that there are no other sequences in the query dataset that are in this tree, transmission between this sequence and other queries can be ruled out.")
        else:            
            print("Tree number " + str(i) + " contains " + str(len(tree_to_tip[lookup])) + " queries.")
            print("There are multiple query sequences in this tree, and so transmission cannot be ruled out, but neither can it be confirmed. Therefore their relationship must be investigated further using epidemiological data.")
        
        for k in range(len(desired_fields)):
            base_number = ((i)*len(desired_fields)) - 1
            print("   ")
            print("![](" + figdir + "/" + name_stem + "_make_trees_" + str(base_number + k) + ".png)")


```

```python, name="Tree error checking", echo=False, results='raw'
if too_tall_trees != []:
    for tree in too_tall_trees:
        print("Tree" + str(tree) + " is too large to be rendered here.")
```
## Tree background

The following plots describe the data in the collapsed nodes in more detail.
If more than one country was present, the bar chart describes the number of sequences present in each country. 
Where there were 10 countries or more, the largest 10 have been taken. 
If a UK sequence is present in the collapsed node, it is always shown in the plot.

```python, name="tree_background", echo=False, include=False, fig=False
bar_count = tree_viz.describe_tree_background(full_tax_dict, tree_dir)
```
```python, name="display bar charts", echo=False, results='raw'
for i in range(bar_count):
    print("![](" + figdir + "/" + name_stem + "_tree_background_" + str(i+1) + ".png)")
```
## Regional-scale Lineage context

```

##### Start Code Execution #####
mapfile=os.path.join(thisdir, "data", "maps", "Mainland_HBs_gapclosed_simplified.geojson")
mainland_boards=gp.read_file(mapfile)
mainland_boards=update_adm15(mainland_boards)
###Get contiguity neighbors for mainland
mainland_boards_W=Queen.from_dataframe(mainland_boards, idVariable='HBCode')
##Hacky fix to link Fife and Lothian
mainland_boards_final_W=getForthBridge(mainland_boards,mainland_boards_W)
###Create translation dict for board codes
HBCode_translation=dict(zip(mainland_boards.HBName, mainland_boards.HBCode))
##########Data loading###########
##Get HB translation dict##
translator=os.path.join(thisdir, "data", "maps", "HB_Translation.pkl")
HBTranslation=pickle.load(f'{data}/maps/HB_Translation.pkl')
### Load cog_data ###
COGDATA=losca.getSampleData(full_metadata_file)
### Load sample data ###
inputSamples = pd.read_csv(input_csv)
###Checking user defined dates###
date_list=None
if date_restriction == 'True':
    if len(date_start) == 10 and len(date_end) == 10:
        date_list={'start': date_start, 'end': date_end}
    elif len(date_start) == 0 and len(date_end) == 0:
        date_list=losca.defineDateRestriction(inputSamples, date_window_size)

cog_restricted = losca.getSampleData_final(COGDATA, date_restriction)

###Preparing cog_meta for spatial filtering & processing
cog_meta_mainland=cog_restricted.loc[cog_restricted['adm1'].isin(['UK-SCT', 'UK-ENG', 'UK-WAL'])]
cog_meta_mainland['HBName']=cog_meta_mainland.loc[:, 'adm2'].map(HBTranslation)
cog_meta_mainland['HBCode']=cog_meta_mainland.loc[:, 'HBName'].map(HBCode_translation)
## Proessing input csv ##

HB_code=losca.adm2_to_centralHBCode(inputSamples['adm2'].to_list())
if HB_code is not None:
    ## Get the localised regions ##
    central, neighboring, submap = losca.central_surrounding_regions(HB_code, mainland_boards_final_W, mainland_boards)
    ## Generate tabular data for each region ##
    for each in [central, neighboring]:
        for row, frame in each.iterrows():
            print(frame['HBName'])
            losca.tabulateLins(frame['HBCode'], cog_meta_mainland)
    ## Generated Mapping ##
    for each, region in [central, neighboring], ['Central Health Board', 'Neighboring Health Boards']:
        print (region)
        losca.vegashow(losca.mapProduce(each, cog_meta_mainland, submap))

```

## Appendix

This report summarises the information provided by whole genome sequencing of SARS-COV-2 generated by the COG consortium. 
It is intended to provide an additional layer of analysis for infection control efforts, and to aid in the investigation of outbreak clusters.

For each query sequence, CIVET either finds them in the COG database, or matches them as closely as possible to a sequence in the COG database, and puts them into a UK lineage.

Key points for interpreting this information:

 - This type of analysis is not able to infer direct transmission between two samples. Even identical sequences may be unrelated as SARS-COV2 is relatively slow evolving for an RNA virus. Our analysis has shown that samples taken over 100 days apart can be identical. 
 - If sequences have different global or UK lineage designations, we can rule out close epidemiological linkage.
 - If sequences have different phylotypes it’s very unlikely that they are direct transmissions. 
 - If sequences share the same lineage and the same phylotype, transmission cannot be ruled out and also cannot be confirmed.


The figure below shows the distribution of time differences that two sequences can be sampled and still be identical. 
It is to illustrate that identical sequences does not confirm linked cases.

```python, name="Identity figure", results='raw', echo=False, fig=True, caption="Distribution of time between identical sequences"
print("![](" + figdir + "/polytomies.png)")
```


### Useful definitions

*Phylotype* 

Each lineage phylogeny is labelled with phylotypes that describe shared mutations in the tree. If two sequences have the same phylotype it means the share mutations. They may also have additional, unique mutations. So having the same phylotype doesn't mean the seqeunces are identical. If sequences have different phylotypes however it means they are present on distinct parts of the phylogenetic tree.

*UK lineage* 

UK lineages are an approximation to distinct introductions of SARS-CoV-2 to the UK based on the phylogenetic tree.

*Global lineage* 

Assigned using the pangolin software, these are phylogenetic lineages. More information can be found at https://github.com/hCoV-2019/lineages

### Software versions

This report was made using:

```python, name='software versions', echo=False, results='raw'

import platform


print("Python " + platform.python_version())

print("Matplotlib version " + matplotlib.__version__)
print("Pandas version " + pd.__version__)
print("Tabulate version " + tabulate.__version__)
print("CSV version " + csv.__version__)
print("Numpy version " + np.__version__)
print("Scipy version " + sp.__version__)
print("No version number for Baltic")


todays_date = dt.date.today()

#This just takes last Friday so if a more continuous pipeline is implemented this will have to be cleverer.
last_friday = todays_date + relativedelta(weekday=FR(-1))
print("The COG data used here was submitted in batch on " + str(last_friday))

print("CIVET version is 0.1")
```

## Acknowledgements

This report was generated by CIVET.

The background data from the UK was generated by the COG consortium (https://www.cogconsortium.uk/), a national, multi-centre consortium for the sequencing and analysis of SARS-CoV-2 genomes for Public Health.

We also use some background data from GISAID (https://www.gisaid.org/) in the phylogenies. We thank everyone involved in the global sequencing effort for making their data available. 

Tree data was visualised using baltic (https://github.com/evogytis/baltic)

